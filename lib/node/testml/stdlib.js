// Generated by CoffeeScript 2.3.0
(function() {
  module.exports = TestML.StdLib = class StdLib {
    constructor(run) {
      this.run = run;
    }

    add(x, y) {
      return x + y;
    }

    block(selector) {
      return this.run.blocks[selector];
    }

    cat(...str) {
      return str.join('');
    }

    count(list) {
      return list[0].length;
    }

    false() {
      return false;
    }

    flat(list, depth = 9999999999) {
      return _.flattenDepth(list, depth);
    }

    head(list) {}

    join(list, separator = ' ') {
      return _.join(list, separator);
    }

    lines(text) {
      text = text.replace(/\n$/, '');
      return [text.split(/\n/)];
    }

    null() {
      return null;
    }

    number(any) {
      return Number(any);
    }

    pairs(list) {
      return _.chunk(list, 2);
    }

    split(string, delim = /\s+/, limit = 0) {
      return _.split(string, delim, limit);
    }

    string(any) {
      return String(any);
    }

    text(list) {
      return [...list[0], ''].join('\n');
    }

    true() {
      return true;
    }

    type(...args) {
      return _.join(_.map(args, function(o) {
        switch (false) {
          case !_.isString(o):
            return 'string';
          case !_.isNumber(o):
            return 'number';
          case !_.isBoolean(o):
            return 'bool';
          case !_.isNull(o):
            return 'null';
          case !_.isArray(o):
            switch (false) {
              case !_.isArray(o[0]):
                return 'list';
              case o[0] !== '/':
                return 'regex';
              case o[0] !== '!':
                return 'error';
              case o[0] !== '?':
                return 'any';
            }
            break;
          default:
            return die(`Can't determine type ${o}`);
        }
      }), '+');
    }

  };

  // vim: ft=coffee sw=2:

}).call(this);
