// Generated by CoffeeScript 2.3.0
(function() {
  // require '../../../../testml-compiler/lib/testml-compiler/prelude'
  var lodash;

  require('../testml');

  lodash = require('lodash');

  module.exports = TestML.Run = (function() {
    class Run {
      //----------------------------------------------------------------------------
      constructor(params = {}) {
        var testml;
        ({file: this.file, bridge: this.bridge, stdlib: this.stdlib, testml = {}} = params);
        ({testml, code: this.code, data: this.data} = testml);
        this.version = testml;
        if (!TestML.browser) {
          global._ = lodash;
        }
        return;
      }

      from_file(file) {
        var fs, testml;
        this.file = file;
        fs = require('fs');
        ({testml, code: this.code, data: this.data} = JSON.parse(this.file === '-' ? fs.readFileSync('/dev/stdin').toString() : fs.readFileSync(this.file).toString()));
        this.version = testml;
        return this;
      }

      test() {
        this.initialize();
        this.test_begin();
        this.exec_func([], this.code);
        this.test_end();
      }

      //----------------------------------------------------------------------------
      getp(name) {
        var value;
        if (!this.block) {
          return;
        }
        value = this.block.point[name];
        if (_.isArray(value)) {
          value = this.exec(value)[0];
        }
        return value;
      }

      getv(name) {
        return this.vars[name];
      }

      setv(name, value) {
        this.vars[name] = value;
      }

      //----------------------------------------------------------------------------
      exec(expr, context = []) {
        var args, call, name, opcode, ref, return_;
        if (!(_.isArray(expr)) || _.isArray(expr[0]) || _.isString(expr[0]) && expr[0].match(/^(?:=>|\/|\?|\!)$/)) {
          return [expr];
        }
        args = _.clone(expr);
        opcode = name = args.shift();
        if (call = this.constructor.vtable[opcode]) {
          return_ = this[call](...args);
        } else {
          args = _.map(args, (x) => {
            if (_.isArray(x)) {
              return this.exec(x)[0];
            } else {
              return x;
            }
          });
          args.unshift(...(_.reverse(context)));
          if (name.match(/^[a-z]/)) {
            call = name.replace(/-/g, '_');
            if (!((ref = this.bridge) != null ? ref[call] : void 0)) {
              throw `Can't find bridge function: '${name}'`;
            }
            return_ = this.bridge[call](...args);
          } else if (name.match(/^[A-Z]/)) {
            call = _.lowerCase(name);
            if (!this.stdlib[call]) {
              throw `Unknown TestML Standard Library function: '${name}'`;
            }
            return_ = this.stdlib[call](...args);
          } else {
            throw `Can't resolve TestML function '${name}'`;
          }
        }
        if (return_ === void 0) {
          return [];
        } else {
          return [return_];
        }
      }

      exec_func(context, [signature, ...function_]) {
        var i, len, statement;
        for (i = 0, len = function_.length; i < len; i++) {
          statement = function_[i];
          this.exec(statement);
        }
      }

      exec_expr(...args) {
        var call, context, i, len;
        context = [];
        for (i = 0, len = args.length; i < len; i++) {
          call = args[i];
          context = this.exec(call, context);
        }
        if (!context.length) {
          return;
        }
        return context[0];
      }

      pick_loop(list, expr) {
        var block, i, j, len, len1, pick, point, ref;
        ref = this.data;
        for (i = 0, len = ref.length; i < len; i++) {
          block = ref[i];
          pick = true;
          for (j = 0, len1 = list.length; j < len1; j++) {
            point = list[j];
            if ((point.match(/^\*/) && (block.point[point.slice(1)] == null)) || (point.match(/^\!\*/) && (block.point[point.slice(2)] != null))) {
              pick = false;
              break;
            }
          }
          if (pick) {
            this.block = block;
            this.exec(expr);
          }
        }
        this.block = void 0;
      }

      get_str(string) {
        string = string.replace(/\{([\-\w+])\}/g, (m, name) => {
          return this.vars[name] || '';
        });
        string = string.replace(/\{\*([\-\w+])\}/g, (m, name) => {
          return this.block.point[name] || '';
        });
        return string;
      }

      get_point(name) {
        return this.getp(name);
      }

      set_var(name, expr) {
        this.setv(name, this.exec(expr)[0]);
      }

      assert_eq(left, right, label_expr) {
        var got, label, want;
        got = this.exec(left)[0];
        want = this.exec(right)[0];
        label = this.get_label(label_expr);
        // method = assertion["eq+#{@stdlib.type(got,want)}"]
        this.test_eq(got, want, label);
      }

      //----------------------------------------------------------------------------
      initialize() {
        this.code.unshift([]);
        this.data = _.map(this.data, (block) => {
          return new TestML.Block(block);
        });
        if (!this.bridge) {
          this.bridge = new (require(process.env.TESTML_BRIDGE));
        }
        if (!this.stdlib) {
          this.stdlib = new (require('../testml/stdlib'));
        }
      }

      get_label(label_expr = '') {
        var block_label, label;
        label = this.exec(label_expr)[0];
        if (!label) {
          label = this.getv('Label') || '';
          if (label.match(/\{\*?[\-\w]+\}/)) {
            label = this.exec(["$''", label])[0];
          }
        }
        block_label = this.block != null ? this.block.label : '';
        if (label) {
          label = label.replace(/^\+/, block_label);
          label = label.replace(/\+$/, block_label);
          label = label.replace(/\{\+\}/, block_label);
        } else {
          label = block_label;
        }
        return label;
      }

    };

    Run.vtable = {
      '==': 'assert_eq',
      '~~': 'assert_has',
      '=~': 'assert_like',
      '%()': 'pick_loop',
      '.': 'exec_expr',
      "$''": 'get_str',
      '*': 'get_point',
      '=': 'set_var'
    };

    Run.prototype.block = void 0;

    Run.prototype.file = void 0;

    Run.prototype.version = void 0;

    Run.prototype.code = void 0;

    Run.prototype.data = void 0;

    Run.prototype.bridge = void 0;

    Run.prototype.stdlib = void 0;

    Run.prototype.vars = {};

    return Run;

  }).call(this);

  //------------------------------------------------------------------------------
  TestML.Block = class {
    constructor({
        label: label1,
        point: point1
      }) {
      this.label = label1;
      this.point = point1;
    }

  };

  // vim: set ft=coffee sw=2:

}).call(this);
