// Generated by CoffeeScript 2.3.0
(function() {
  var lodash;

  require('../testml');

  if (TestML.env['TESTML_DEVEL']) {
    require('ingy-prelude');
  }

  lodash = require('lodash');

  module.exports = TestML.Run = (function() {
    class Run {
      //----------------------------------------------------------------------------
      constructor(params = {}) {
        var testml;
        ({file: this.file, bridge: this.bridge, stdlib: this.stdlib, testml = {}} = params);
        ({testml, code: this.code, data: this.data} = testml);
        this.version = testml;
        if (!TestML.browser) {
          global._ = lodash;
        }
        return;
      }

      from_file(file) {
        var fs, testml;
        this.file = file;
        fs = require('fs');
        ({testml, code: this.code, data: this.data} = JSON.parse(this.file === '-' ? fs.readFileSync('/dev/stdin').toString() : fs.readFileSync(this.file).toString()));
        this.version = testml;
        return this;
      }

      test() {
        var i, len, ref, statement;
        this.initialize();
        this.testml_begin();
        ref = this.code;
        for (i = 0, len = ref.length; i < len; i++) {
          statement = ref[i];
          this.exec(statement);
        }
        this.testml_end();
      }

      //----------------------------------------------------------------------------
      getp(name) {
        var value;
        if (!this.block) {
          return;
        }
        value = this.block.point[name];
        if (_.isArray(value)) {
          value = this.exec(value)[0];
        }
        return value;
      }

      getv(name) {
        return this.vars[name];
      }

      setv(name, value) {
        this.vars[name] = value;
      }

      //----------------------------------------------------------------------------
      exec(expr, context = []) {
        var args, call, name, opcode, return_, value;
        if (!(_.isArray(expr)) || _.isArray(expr[0]) || _.isPlainObject(expr[0]) || _.isString(expr[0]) && expr[0].match(/^(?:\/|\?|\!)$/)) {
          return [expr];
        }
        args = _.clone(expr);
        opcode = name = args.shift();
        if (call = this.constructor.vtable[opcode]) {
          if (_.isArray(call)) {
            call = call[0];
          }
          // Might need to pass context to => calls here.
          return_ = this[call](...args);
        } else {
          args.unshift(...(_.reverse(context)));
          if ((value = this.vars[name]) != null) {
            if (args.length) {
              return_ = this.exec(value, ...args);
            } else {
              return_ = value;
            }
          } else if (name.match(/^[a-z]/)) {
            return_ = this.exec_bridge_function(name, args);
          } else if (name.match(/^[A-Z]/)) {
            return_ = this.exec_stdlib_function(name, args);
          } else {
            throw `Can't resolve TestML function '${name}'`;
          }
        }
        if (return_ === void 0) {
          return [];
        } else {
          return [return_];
        }
      }

      exec_bridge_function(name, args) {
        var call, ref, return_;
        call = name.replace(/-/g, '_');
        if (!((ref = this.bridge) != null ? ref[call] : void 0)) {
          throw `Can't find bridge function: '${name}'`;
        }
        args = _.map(args, (x) => {
          var v;
          v = this.exec(x)[0];
          if (_.isArray(v)) {
            return v[0];
          } else {
            return v;
          }
        });
        return_ = this.bridge[call](...args);
        if (return_ && this.get_type(return_).match(/^(list|hash)$/)) {
          return_ = [return_];
        }
        return return_;
      }

      exec_stdlib_function(name, args) {
        var call;
        call = _.lowerCase(name);
        if (!this.stdlib[call]) {
          throw `Unknown TestML Standard Library function: '${name}'`;
        }
        args = _.map(args, (x) => {
          return this.exec(x)[0];
        });
        return this.stdlib[call](...args);
      }

      exec_expr(...calls) {
        var call, context, e, i, len;
        context = [];
        this.error = null;
        for (i = 0, len = calls.length; i < len; i++) {
          call = calls[i];
          if (!this.error) {
            try {
              context = this.exec(call, context);
            } catch (error) {
              e = error;
              this.error = ['!', e];
            }
          } else if (call[0] === 'Catch') {
            context = [this.error];
            this.error = null;
          }
        }
        if (this.error) {
          throw this.error[1];
        }
        if (!context.length) {
          return;
        }
        return context[0];
      }

      pick_loop(list, expr) {
        var block, i, len, ref;
        ref = this.data;
        for (i = 0, len = ref.length; i < len; i++) {
          block = ref[i];
          this.block = block;
          if (block.point.ONLY && !this.warned_only) {
            this.warn("Warning: TestML 'ONLY' in use.");
            this.warned_only = true;
          }
          this.exec(['()', list, expr]);
        }
        this.block = void 0;
      }

      pick_exec(list, expr) {
        var i, len, pick, point;
        pick = true;
        for (i = 0, len = list.length; i < len; i++) {
          point = list[i];
          if ((point.match(/^\*/) && (this.block.point[point.slice(1)] == null)) || (point.match(/^\!\*/) && (this.block.point[point.slice(2)] != null))) {
            pick = false;
            break;
          }
        }
        if (pick) {
          return this.exec(expr);
        }
      }

      exec_func(signature, statements) {
        var i, len, results, statement;
        results = [];
        for (i = 0, len = statements.length; i < len; i++) {
          statement = statements[i];
          results.push(this.exec(statement));
        }
        return results;
      }

      call_func(name) {
        var func;
        func = this.vars[name];
        if (!((func != null) && this.get_type(func) === 'func')) {
          throw `Tried to call '${name}' but is not a function`;
        }
        return this.exec(func);
      }

      get_str(string) {
        return this.interpolate(string);
      }

      get_hash(hash, key) {
        hash = this.exec(hash)[0];
        return hash[0][key];
      }

      get_point(name) {
        return this.getp(name);
      }

      set_var(name, expr) {
        if (this.get_type(expr === 'func')) {
          this.setv(name, expr);
        } else {
          this.setv(name, this.exec(expr)[0]);
        }
      }

      assert_eq(left, right, label) {
        var got, method, want;
        this.vars.Got = got = this.exec(left)[0];
        this.vars.Want = want = this.exec(right)[0];
        method = this.get_method('==', got, want);
        this[method](got, want, label);
      }

      assert_str_eq_str(got, want, label) {
        return this.testml_eq(got, want, this.get_label(label));
      }

      assert_num_eq_num(got, want, label) {
        return this.testml_eq(got, want, this.get_label(label));
      }

      assert_bool_eq_bool(got, want, label) {
        return this.testml_eq(got, want, this.get_label(label));
      }

      assert_has(left, right, label) {
        var got, method, want;
        got = this.exec(left)[0];
        want = this.exec(right)[0];
        method = this.get_method('~~', got, want);
        this[method](got, want, label);
      }

      assert_str_has_str(got, want, label) {
        this.vars.Got = got;
        this.vars.Want = want;
        return this.testml_has(got, want, this.get_label(label));
      }

      assert_str_has_list(got, want, label) {
        var i, len, ref, results, str;
        ref = want[0];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          str = ref[i];
          results.push(this.assert_str_has_str(got, str, label));
        }
        return results;
      }

      assert_list_has_str(got, want, label) {
        this.vars.Got = got;
        this.vars.Want = want;
        return this.testml_list_has(got[0], want, this.get_label(label));
      }

      assert_list_has_list(got, want, label) {
        var i, len, ref, results, str;
        ref = want[0];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          str = ref[i];
          results.push(this.assert_list_has_str(got, str, label));
        }
        return results;
      }

      assert_like(left, right, label) {
        var got, method, want;
        got = this.exec(left)[0];
        want = this.exec(right)[0];
        method = this.get_method('=~', got, want);
        this[method](got, want, label);
      }

      assert_str_like_regex(got, want, label) {
        this.vars.Got = got;
        this.vars.Want = `/${want[1]}/`;
        return this.testml_like(got, want[1], this.get_label(label));
      }

      assert_str_like_list(got, want, label) {
        var i, len, ref, regex, results;
        ref = want[0];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          regex = ref[i];
          results.push(this.assert_str_like_regex(got, regex, label));
        }
        return results;
      }

      assert_list_like_regex(got, want, label) {
        var i, len, ref, results, str;
        ref = got[0];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          str = ref[i];
          results.push(this.assert_str_like_regex(str, want, label));
        }
        return results;
      }

      assert_list_like_list(got, want, label) {
        var i, len, ref, regex, results, str;
        ref = got[0];
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          str = ref[i];
          results.push((function() {
            var j, len1, ref1, results1;
            ref1 = want[0];
            results1 = [];
            for (j = 0, len1 = ref1.length; j < len1; j++) {
              regex = ref1[j];
              results1.push(this.assert_str_like_regex(str, regex, label));
            }
            return results1;
          }).call(this));
        }
        return results;
      }

      //----------------------------------------------------------------------------
      initialize() {
        this.data = _.map(this.data, (block) => {
          return new TestML.Block(block);
        });
        if (!this.bridge) {
          try {
            this.bridge = new (require(process.env.TESTML_BRIDGE));
          } catch (error) {}
        }
        if (!this.stdlib) {
          this.stdlib = new (require('../testml/stdlib'))(this);
        }
      }

      get_method(key, ...args) {
        var arg, entry, i, len, method, name, pattern, sig, sig_str, vtable;
        sig = [];
        for (i = 0, len = args.length; i < len; i++) {
          arg = args[i];
          sig.push(this.get_type(arg));
        }
        sig_str = sig.join(',');
        entry = this.constructor.vtable[key];
        [name, pattern, vtable] = entry;
        method = vtable[sig_str] || pattern.replace(/%(\d+)/g, function(m, num) {
          return sig[num - 1];
        });
        if (!method) {
          throw `Can't resolve ${name}(${sig_str})`;
        }
        if (!this[method]) {
          throw `Method '${method}' does not exist`;
        }
        return method;
      }

      get_type(object) {
        var type;
        type = (function() {
          switch (false) {
            case object !== null:
              return 'null';
            case typeof object !== 'string':
              return 'str';
            case typeof object !== 'number':
              return 'num';
            case typeof object !== 'boolean':
              return 'bool';
            case !(object instanceof Array):
              switch (false) {
                case !(object[0] instanceof Array):
                  return 'list';
                case !_.isPlainObject(object[0]):
                  return 'hash';
                case object[0] !== '=>':
                  return 'func';
                case object[0] !== '/':
                  return 'regex';
                case object[0] !== '!':
                  return 'error';
                default:
                  return 'expr';
              }
              break;
            default:
              return null;
          }
        })();
        if (!type) {
          throw `Can't get type of ${require('util').inspect(object)}`;
        }
        return type;
      }

      get_label(label_expr = '') {
        var block_label, label;
        label = this.exec(label_expr)[0];
        label || (label = this.getv('Label') || '');
        block_label = this.block != null ? this.block.label : '';
        if (label) {
          label = label.replace(/^\+/, block_label);
          label = label.replace(/\+$/, block_label);
          label = label.replace(/\{\+\}/, block_label);
        } else {
          label = block_label;
        }
        return this.interpolate(label, true);
      }

      interpolate(string, label = false) {
        var transform, transform1, transform2;
        transform = (value) => {
          if (label) {
            switch (false) {
              case !this.get_type(value).match(/^(?:list|hash)$/):
                return JSON.stringify(value[0]).replace(/"/g, '');
              default:
                return String(value).replace(/\n/g, '␤');
            }
          } else {
            switch (false) {
              case !this.get_type(value).match(/^(?:list|hash)$/):
                return JSON.stringify(value[0]).replace(/"/g, '');
              default:
                return String(value);
            }
          }
        };
        transform1 = (m, name) => {
          var value;
          if ((value = this.vars[name]) == null) {
            return '';
          }
          return transform(value);
        };
        transform2 = (m, name) => {
          var ref, value;
          if ((value = (ref = this.block) != null ? ref.point[name] : void 0) == null) {
            return '';
          }
          return transform(value);
        };
        string = string.replace(/\{([\-\w]+)\}/g, transform1);
        string = string.replace(/\{\*([\-\w]+)\}/g, transform2);
        return string;
      }

    };

    Run.vtable = {
      '==': [
        'assert_eq',
        'assert_%1_eq_%2',
        {
          'str,str': '',
          'num,num': '',
          'bool,bool': ''
        }
      ],
      '~~': [
        'assert_has',
        'assert_%1_has_%2',
        {
          'str,str': '',
          'str,list': '',
          'list,str': '',
          'list,list': ''
        }
      ],
      '=~': [
        'assert_like',
        'assert_%1_like_%2',
        {
          'str,regex': '',
          'str,list': '',
          'list,regex': '',
          'list,list': ''
        }
      ],
      '.': 'exec_expr',
      '%()': 'pick_loop',
      '()': 'pick_exec',
      '=>': 'exec_func',
      '&': 'call_func',
      "$''": 'get_str',
      ":": 'get_hash',
      '*': 'get_point',
      '=': 'set_var'
    };

    Run.prototype.block = void 0;

    Run.prototype.file = void 0;

    Run.prototype.version = void 0;

    Run.prototype.code = void 0;

    Run.prototype.data = void 0;

    Run.prototype.bridge = void 0;

    Run.prototype.stdlib = void 0;

    Run.prototype.vars = {};

    Run.prototype.warned_only = false;

    Run.prototype.error = null;

    return Run;

  }).call(this);

  //------------------------------------------------------------------------------
  TestML.Block = class {
    constructor({
        label: label1,
        point: point1
      }) {
      this.label = label1;
      this.point = point1;
    }

  };

}).call(this);
