// Generated by CoffeeScript 2.3.0
(function() {
  // require '../../../../testml-compiler/lib/testml-compiler/prelude'
  var lodash, operator;

  require('../testml');

  lodash = require('lodash');

  operator = {
    '==': 'eq',
    '.': 'call',
    '=>': 'func',
    "$''": 'get-string',
    '[]': 'list',
    '%()': 'pickloop',
    '*': 'point',
    '/': 'regex',
    '=': 'set-var'
  };

  module.exports = TestML.Run = class Run {
    constructor(params = {}) {
      var testml;
      ({file: this.file, testml = {}, bridge: this.bridge, stdlib: this.stdlib} = params);
      ({testml, code: this.code, data: this.data} = testml);
      this.version = testml;
      this.vars = {};
      if (!TestML.browser) {
        global._ = lodash;
      }
      return;
    }

    from_file(file) {
      var fs, testml;
      this.file = file;
      fs = require('fs');
      ({testml, code: this.code, data: this.data} = JSON.parse(this.file === '-' ? fs.readFileSync('/dev/stdin').toString() : fs.readFileSync(this.file).toString()));
      this.version = testml;
      return this;
    }

    test() {
      this.initialize();
      this.test_begin();
      this.exec(this.code);
      this.test_end();
    }

    //----------------------------------------------------------------------------
    getp(name) {
      var value;
      if (!this.block) {
        return;
      }
      value = this.block.point[name];
      if (_.isArray(value)) {
        value = this.exec(value)[0];
      }
      return value;
    }

    getv(name) {
      return this.vars[name];
    }

    setv(name, value) {
      this.vars[name] = value;
    }

    //----------------------------------------------------------------------------
    exec(expr, context = []) {
      var args, call, name, opname, ref, return_;
      if (!_.isArray(expr)) {
        return [expr];
      }
      args = _.clone(expr);
      name = call = args.shift();
      if (opname = operator[call]) {
        call = `exec_${opname}`.replace(/-/g, '_');
        return_ = this[call](...args);
      } else {
        args = _.map(args, (x) => {
          if (_.isArray(x)) {
            return this.exec(x)[0];
          } else {
            return x;
          }
        });
        args.unshift(...(_.reverse(context)));
        if (call.match(/^[a-z]/)) {
          call = call.replace(/-/g, '_');
          if (!((ref = this.bridge) != null ? ref[call] : void 0)) {
            throw `Can't find bridge function: '${name}'`;
          }
          return_ = this.bridge[call](...args);
        } else if (call.match(/^[A-Z]/)) {
          call = _.lowerCase(call);
          if (!this.stdlib[call]) {
            throw `Unknown TestML Standard Library function: '${name}'`;
          }
          return_ = this.stdlib[call](...args);
        } else {
          throw `Can't resolve TestML function '${name}'`;
        }
      }
      if (return_ === void 0) {
        return [];
      } else {
        return [return_];
      }
    }

    exec_call(...args) {
      var call, context, i, len;
      context = [];
      for (i = 0, len = args.length; i < len; i++) {
        call = args[i];
        context = this.exec(call, context);
      }
      if (!context.length) {
        return;
      }
      return context[0];
    }

    exec_eq(left, right, label_expr) {
      var got, label, want;
      got = this.exec(left)[0];
      want = this.exec(right)[0];
      label = this.get_label(label_expr);
      this.test_eq(got, want, label);
    }

    exec_func(signature, ...statements) {
      var i, len, statement;
      for (i = 0, len = statements.length; i < len; i++) {
        statement = statements[i];
        this.exec(statement);
      }
    }

    exec_get_string(string) {
      string = string.replace(/\{([\-\w+])\}/g, (m, name) => {
        return this.vars[name] || '';
      });
      string = string.replace(/\{\*([\-\w+])\}/g, (m, name) => {
        return this.block.point[name] || '';
      });
      return string;
    }

    exec_list(...expr) {
      return expr;
    }

    exec_pickloop(list, expr) {
      var block, i, j, len, len1, pick, point, ref;
      ref = this.data;
      for (i = 0, len = ref.length; i < len; i++) {
        block = ref[i];
        pick = true;
        for (j = 0, len1 = list.length; j < len1; j++) {
          point = list[j];
          if ((point.match(/^\*/) && (block.point[point.slice(1)] == null)) || (point.match(/^\!\*/) && (block.point[point.slice(2)] != null))) {
            pick = false;
            break;
          }
        }
        if (pick) {
          this.block = block;
          this.exec(expr);
        }
      }
      this.block = void 0;
    }

    exec_point(name) {
      return this.getp(name);
    }

    exec_regex(regex) {
      return new RegExp(regex);
    }

    exec_set_var(name, expr) {
      this.setv(name, this.exec(expr)[0]);
    }

    //----------------------------------------------------------------------------
    initialize() {
      this.code.unshift('=>', []);
      this.data = _.map(this.data, (block) => {
        return new TestML.Block(block);
      });
      if (!this.bridge) {
        this.bridge = new (require(process.env.TESTML_BRIDGE));
      }
      if (!this.stdlib) {
        this.stdlib = new (require('../testml/stdlib'));
      }
    }

    get_label(label_expr = '') {
      var block_label, label;
      label = this.exec(label_expr)[0];
      block_label = this.block != null ? this.block.label : '';
      if (label) {
        label = label.replace(/^\+/, block_label);
        label = label.replace(/\+$/, block_label);
        label = label.replace(/\{\+\}/, block_label);
      } else {
        label = block_label;
      }
      return label;
    }

  };

  //------------------------------------------------------------------------------
  TestML.Block = class {
    constructor({
        label: label1,
        point: point1
      }) {
      this.label = label1;
      this.point = point1;
    }

  };

  // vim: set ft=coffee sw=2:

}).call(this);
